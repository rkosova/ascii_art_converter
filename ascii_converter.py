import random

class ASCIIArtist():
	def __init__(self, num_matrix):
		"""Constructor sets up matrix as a class field and the matrix of possible ASCII characters

		:param num_matrix: number matrix of generated gray RGBs 
		:type num_matrix: list
		"""
		self.matrix = num_matrix
		self.ascii_alphabet = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "a", "B", "b", "C", "c", "D", "d",
							"E", "e", "F", "f", "G", "g", "H", "h", "I", "i", "J", "j", "K", "k", "L", "l", "M",
						    "m", "N", "n", "O", "o", "P", "p", "Q", "q", "R", "r", "S", "s", "T", "t", "U", "u",
						    "V", "v", "W", "w", "X", "x", "Y", "y", "Z", "z", "=", "-", "_", "+", "|", ";", ":",
						    '"', "'", ",", "<", ".", ">", "/", "?", "!", "@", "#", "$", "%", "^", "&", "*", "(",
						    ")", "~"]
		self.mod_n = [2]

	
	def generate_color_dict(self, shade_consistent=False, detail=0.4):
		"""Generates appropriate dictionary of ASCII characters corresponding to the relative range of darkest-to-lightest values in the num_matrix

		:param shade_consistent: if true, the generator will try to match the shade (or "darkness") of the cells/grayscaled pixels with an aproppriate character, defaults to False
		:type shade_consistent: boolean

		:param detail: float value in range (0, 1), determines the diversity of ASCII characters. The higher the float value, the more diversity
		:type detail: float 

		:rtype: dictionary
		:return: dictionary where keys are RGB values spaced equally (as possible) and values are random ASCII to be placed for values below their corresponding key
	"""
		assert !shade_consistent, "shade_consistent algorithm(s) still not implemented"

		if not shade_consistent:
			_matrix = []
			for nested in self.matrix: 
				_matrix += nested
			_matrix.sort()
			darkest = _matrix[0]
			lightest = _matrix[-1]
			range_of_shades = (lightest-darkest) + 1
			n=1
			while (range_of_shades%self.mod_n[-1] < range_of_shades):
				n+=1
				self.mod_n.append(self.mod_n[0] ** n) # FIX WHEN NOT TIRED
				# print(self.mod_n[n-1])

			self.ind_detailed = (round(len(self.mod_n)*detail))
			multiplier = range_of_shades//self.mod_n[-self.ind_detailed]
			remainder = range_of_shades%self.mod_n[-self.ind_detailed]
			# print(self.mod_n[-self.ind_detailed], multiplier, remainder, range_of_shades)
			used = []
			for _ in range(multiplier + self.mod_n[-self.ind_detailed]):
				used.append(random.randrange(len(self.ascii_alphabet)))
			used = iter(used)
			#_darkest = darkest.copy()
			if range_of_shades%self.mod_n[-self.ind_detailed] == 0:
				color_range_dict = {darkest + x: self.ascii_alphabet[next(used)] for x in range(0, range_of_shades, self.mod_n[-self.ind_detailed])}
				# print(color_range_dict)
			else:
				color_range_dict = {darkest + x: self.ascii_alphabet[next(used)] for x in range(0, range_of_shades-remainder+self.mod_n[-self.ind_detailed], self.mod_n[-self.ind_detailed])}
				color_range_dict[range_of_shades] = self.ascii_alphabet[next(used)]

			return color_range_dict


	def generate_ascii_file(self, ascii_diction, fname):
		"""Generates .txt file with ASCII art

			:param ascii_diction: color range dictionary generated by generate_color_dict()
			:type ascii_diction: dictionary

			:param fname: file name
			:type fname: string

			:return: writes a file
		"""
		f = open(fname + ".txt", "w")
		for y in range(len(self.matrix)):
			for x in range(len(self.matrix[0])):
				for i in range(len(ascii_diction.keys())):
					if (self.matrix[y][x] >= list(ascii_diction.keys())[i]) & (self.matrix[y][x] < list(ascii_diction.keys())[i] + self.mod_n[-self.ind_detailed]):
						f.write(str(ascii_diction[list(ascii_diction.keys())[i]]))
						f.write(" ")
						break

			f.write("\n")

		f.close()



